name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

env:
  MIRROR_URL: "git@github.com:EpitechPGE3-2025/G-CPP-500-NAN-5-2-rtype-2.git"

jobs:
  check_repository:
    name: check repository to start jobs
    runs-on: ubuntu-latest
    outputs:
      target: ${{ steps.new_output.outputs.value }}
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: CHECK TARGET REPOSITORY
        id: new_output
        run: |
          temp=$(echo $MIRROR_URL | cut -d ':' -f 2 | sed "s/\.git//")
          if [ $temp = ${{ github.repository }} ]; then
            echo "::notice title=The target repository is also the current one::$temp"
            echo "value=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "value=0" >> "$GITHUB_OUTPUT"
          exit 0

  check_coding_style:
    name: check any coding style errors
    needs: [check_repository]
    if: ${{ needs.check_repository.outputs.target == 0 }}
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: INSTALL CPP LINTER
        run: |
          apt update && apt install -y python3-pip
          pip install cpplint
          chmod +x ./scripts/cpp_style_checker.sh

      - name: CHECK CODING STYLE
        run: |
          ./scripts/cpp_style_checker.sh

      - name: VERIFY CPP CODING STYLE
        run: |
          if [ -s coding-style-cpp-reports.log ]; then
            echo "CPP coding style errors found. See coding-style-cpp-reports.log for details."
            cat coding-style-cpp-reports.log
            exit 1
          else
            echo "No CPP coding style errors found."
          fi

  check_ubuntu_compilation:
    name: check project compilation on ubuntu
    needs: [check_coding_style]
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: INSTALL DEPENDENCIES
        run: |
          sudo apt install -y cmake g++ make git build-essential ninja-build libx11-dev libxi-dev libxrandr-dev libxcursor-dev libudev-dev libgl1-mesa-dev
          git clone https://github.com/Microsoft/vcpkg.git
          cd vcpkg
          ./bootstrap-vcpkg.sh
          echo "VCPKG_ROOT=$(pwd)" >> $GITHUB_ENV

      - name: RUN COMPILATION
        run: |
          chmod +x ./scripts/compile_project.sh
          ./scripts/compile_project.sh

  check_windows_compilation:
    name: check project compilation on windows
    needs: [check_coding_style]
    runs-on: windows-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: INSTALL DEPENDENCIES
        run: |
          git clone https://github.com/Microsoft/vcpkg.git
          cd vcpkg
          .\bootstrap-vcpkg.bat
          echo "VCPKG_ROOT=$PWD" >> $env:GITHUB_ENV

      - name: RUN COMPILATION
        run: |
          .\scripts\compile_project.bat
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Compilation failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }

  run_all_tests:
    name: run all tests
    needs: [check_ubuntu_compilation, check_windows_compilation]
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: INSTALL DEPENDENCIES
        run: |
          sudo apt install -y cmake g++ make git build-essential ninja-build libx11-dev libxi-dev libxrandr-dev libxcursor-dev libudev-dev libgl1-mesa-dev
          git clone https://github.com/Microsoft/vcpkg.git
          cd vcpkg
          ./bootstrap-vcpkg.sh
          echo "VCPKG_ROOT=$(pwd)" >> $GITHUB_ENV

      - name: RUN COMPILATION
        run: |
          chmod +x ./scripts/compile_project.sh
          ./scripts/compile_project.sh --with-tests

      - name: RUN UNIT TESTS
        run: |
          chmod +x ./scripts/run_unit_tests.sh
          ./scripts/run_unit_tests.sh

  push_to_mirror:
    name: push to target repository
    needs: [run_all_tests]
    if: ${{ github.event_name == 'push' }}
    environment: RTYPE
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: REPOSITORY MIRRORING
        uses: pixta-dev/repository-mirroring-action@v1
        with:
          target_repo_url: ${{ env.MIRROR_URL }}
          ssh_private_key: ${{ secrets.GIT_SSH_PRIVATE_KEY }}

  calculate_version:
    name: calculate semantic version
    needs: [run_all_tests]
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.semver.outputs.version }}
      version_type: ${{ steps.semver.outputs.version_type }}
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GET VERSION TYPE FROM PR LABELS
        id: get_version_type
        run: |
          # Get labels from the latest merged PR
          PR_NUMBER=$(gh pr list --state merged --limit 1 --json number --jq '.[0].number')
          if [ -n "$PR_NUMBER" ]; then
            LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name')
            echo "Labels found: $LABELS"
            
            if echo "$LABELS" | grep -q "release:major"; then
              echo "type=major" >> "$GITHUB_OUTPUT"
            elif echo "$LABELS" | grep -q "release:minor"; then
              echo "type=minor" >> "$GITHUB_OUTPUT"
            elif echo "$LABELS" | grep -q "release:patch"; then
              echo "type=patch" >> "$GITHUB_OUTPUT"
            else
              echo "type=none" >> "$GITHUB_OUTPUT"
              echo "::notice::No release label found, will keep current version"
            fi
          else
            echo "type=none" >> "$GITHUB_OUTPUT"
            echo "::notice::No merged PR found, will keep current version"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: CALCULATE SEMANTIC VERSION
        id: semver
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION=${LATEST_TAG#v}
          
          # SSeparate major.minor.patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Increment according to the type
          VERSION_TYPE="${{ steps.get_version_type.outputs.type }}"

          if [ "$VERSION_TYPE" = "none" ]; then
            # No label, keep the current version
            NEW_VERSION="$LATEST_TAG"
            echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
            echo "version_type=no-change" >> "$GITHUB_OUTPUT"
            echo "::notice::No release label, keeping current version $NEW_VERSION"
          else
            # Increment the version
            case "$VERSION_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
            echo "version_type=$VERSION_TYPE" >> "$GITHUB_OUTPUT"
            echo "::notice::New version will be $NEW_VERSION (type: $VERSION_TYPE)"
          fi

  create_unix_release:
    name: create unix release
    needs: [calculate_version]
    if: ${{ github.event_name == 'push' }}
    environment: RTYPE
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: CREATE RELEASE ARCHIVE
        run: |
          mkdir -p release-package
          cp -r client server common libs scripts tests CMakeLists.txt CMakePresets.json vcpkg.json release-package/
          cd release-package
          zip -r ../rtype-unix-${{ needs.calculate_version.outputs.version }}.zip .
          cd ..

      - name: CREATE UNIX RELEASE
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.calculate_version.outputs.version }}
          allowUpdates: true
          name: Unix Release ${{ needs.calculate_version.outputs.version }}
          body: |
            Automated Unix release ${{ needs.calculate_version.outputs.version }}
            
            **Version Type:** `${{ needs.calculate_version.outputs.version_type }}`

            ## ðŸ“¦ Installation
            1. Download `rtype-unix-${{ needs.calculate_version.outputs.version }}.zip`
            2. Unzip: `unzip rtype-unix-${{ needs.calculate_version.outputs.version }}.zip`
            3. Compile: `chmod +x scripts/compile_project.sh && ./scripts/compile_project.sh`
          draft: false
          prerelease: false
          artifacts: "rtype-unix-${{ needs.calculate_version.outputs.version }}.zip"
          artifactContentType: application/zip

  create_windows_release:
    name: create windows release
    needs: [calculate_version]
    if: ${{ github.event_name == 'push' }}
    environment: RTYPE
    runs-on: windows-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: INSTALL DEPENDENCIES
        run: |
          git clone https://github.com/Microsoft/vcpkg.git
          cd vcpkg
          .\bootstrap-vcpkg.bat
          echo "VCPKG_ROOT=$PWD" >> $env:GITHUB_ENV

      - name: BUILD PROJECT
        run: |
          .\scripts\compile_project.bat

      - name: CREATE RELEASE ARCHIVES
        run: |
          Compress-Archive -Path "build\windows\bin\client\*.exe", "build\windows\bin\client\*.dll" -DestinationPath "rtype-client-windows-${{ needs.calculate_version.outputs.version }}.zip"
          Compress-Archive -Path "build\windows\bin\server\*.exe", "build\windows\bin\server\*.dll" -DestinationPath "rtype-server-windows-${{ needs.calculate_version.outputs.version }}.zip"

      - name: CREATE WINDOWS RELEASE
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.calculate_version.outputs.version }}
          allowUpdates: true
          name: Windows Release ${{ needs.calculate_version.outputs.version }}
          body: |
            Automated Windows release ${{ needs.calculate_version.outputs.version }}
            
            **Version Type:** `${{ needs.calculate_version.outputs.version_type }}`

            ## ðŸ“¦ Installation
            1. Download `rtype-windows-${{ needs.calculate_version.outputs.version }}.zip`
            2. Unzip the archive
            3. Run `r-type_client.exe` or `r-type_server.exe`
          draft: false
          prerelease: false
          artifacts: "rtype-client-windows-${{ needs.calculate_version.outputs.version }}.zip, rtype-server-windows-${{ needs.calculate_version.outputs.version }}.zip"
          artifactContentType: application/zip
