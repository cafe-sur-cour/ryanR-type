name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

env:
  MIRROR_URL: "git@github.com:EpitechPGE3-2025/G-CPP-500-NAN-5-2-rtype-2.git"

jobs:
  check_repository:
    name: check repository to start jobs
    runs-on: ubuntu-latest
    outputs:
      target: ${{ steps.new_output.outputs.value }}
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: CHECK TARGET REPOSITORY
        id: new_output
        run: |
          temp=$(echo $MIRROR_URL | cut -d ':' -f 2 | sed "s/\.git//")
          if [ $temp = ${{ github.repository }} ]; then
            echo "::notice title=The target repository is also the current one::$temp"
            echo "value=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "value=0" >> "$GITHUB_OUTPUT"
          exit 0

  check_coding_style:
    name: check any coding style errors
    needs: [check_repository]
    if: ${{ needs.check_repository.outputs.target == 0 }}
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4

      - name: SETUP PYTHON
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          cache: 'pip'

      - name: CACHE CPPLINT
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-cpplint-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-cpplint-
            ${{ runner.os }}-pip-

      - name: INSTALL CPP LINTER
        run: |
          pip install cpplint
          chmod +x ./scripts/cpp_style_checker.sh

      - name: CHECK CODING STYLE
        run: |
          ./scripts/cpp_style_checker.sh

      - name: VERIFY CPP CODING STYLE
        run: |
          if [ -s coding-style-cpp-reports.log ]; then
            echo "CPP coding style errors found. See coding-style-cpp-reports.log for details."
            cat coding-style-cpp-reports.log
            exit 1
          else
            echo "No CPP coding style errors found."
          fi

  check_ubuntu_compilation:
    name: check project compilation on ubuntu
    needs: [check_coding_style]
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: CACHE SYSTEM PACKAGES
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: cmake g++ make git build-essential ninja-build libx11-dev libxi-dev libxrandr-dev libxcursor-dev libudev-dev libgl1-mesa-dev
          version: 1.0

      - name: CACHE VCPKG
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~/.cache/vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: INSTALL VCPKG
        run: |
          if [ ! -d "vcpkg" ]; then
            git clone https://github.com/Microsoft/vcpkg.git
            cd vcpkg
            ./bootstrap-vcpkg.sh
          fi
          echo "VCPKG_ROOT=$(pwd)/vcpkg" >> $GITHUB_ENV

      - name: CACHE CMAKE BUILD
        uses: actions/cache@v4
        with:
          path: |
            build/unix
            ~/.cache/cmake
          key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-cmake-

      - name: RUN COMPILATION
        run: |
          chmod +x ./scripts/compile_project.sh
          ./scripts/compile_project.sh

  check_windows_compilation:
    name: check project compilation on windows
    needs: [check_coding_style]
    runs-on: windows-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: CACHE VCPKG
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~\AppData\Local\vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: INSTALL VCPKG
        run: |
          if (-not (Test-Path "vcpkg")) {
            git clone https://github.com/Microsoft/vcpkg.git
            cd vcpkg
            .\bootstrap-vcpkg.bat
          }
          echo "VCPKG_ROOT=$PWD\vcpkg" >> $env:GITHUB_ENV

      - name: CACHE CMAKE BUILD
        uses: actions/cache@v4
        with:
          path: |
            build/windows
            ~\AppData\Local\cmake
          key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-cmake-

      - name: RUN COMPILATION
        run: |
          .\scripts\compile_project.bat
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Compilation failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }

  run_all_tests:
    name: run all tests
    needs: [check_ubuntu_compilation, check_windows_compilation]
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: CACHE SYSTEM PACKAGES
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: cmake g++ make git build-essential ninja-build libx11-dev libxi-dev libxrandr-dev libxcursor-dev libudev-dev libgl1-mesa-dev
          version: 1.0

      - name: CACHE VCPKG
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~/.cache/vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      - name: INSTALL VCPKG
        run: |
          if [ ! -d "vcpkg" ]; then
            git clone https://github.com/Microsoft/vcpkg.git
            cd vcpkg
            ./bootstrap-vcpkg.sh
          fi
          echo "VCPKG_ROOT=$(pwd)/vcpkg" >> $GITHUB_ENV

      - name: CACHE CMAKE BUILD WITH TESTS
        uses: actions/cache@v4
        with:
          path: |
            build/unix
            ~/.cache/cmake
          key: ${{ runner.os }}-cmake-tests-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-cmake-tests-
            ${{ runner.os }}-cmake-

      - name: RUN COMPILATION
        run: |
          chmod +x ./scripts/compile_project.sh
          ./scripts/compile_project.sh --with-tests

      - name: RUN UNIT TESTS
        run: |
          chmod +x ./scripts/run_unit_tests.sh
          ./scripts/run_unit_tests.sh

  push_to_mirror:
    name: push to target repository
    needs: [run_all_tests]
    if: ${{ github.event_name == 'push' }}
    environment: RTYPE
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: REPOSITORY MIRRORING
        uses: pixta-dev/repository-mirroring-action@v1
        with:
          target_repo_url: ${{ env.MIRROR_URL }}
          ssh_private_key: ${{ secrets.GIT_SSH_PRIVATE_KEY }}

  calculate_version:
    name: calculate semantic version
    needs: [run_all_tests]
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.semver.outputs.version }}
      version_type: ${{ steps.semver.outputs.version_type }}
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GET VERSION TYPE FROM PR LABELS
        id: get_version_type
        run: |
          # Get labels from the latest merged PR
          PR_NUMBER=$(gh pr list --state merged --limit 1 --json number --jq '.[0].number')
          if [ -n "$PR_NUMBER" ]; then
            LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name')
            echo "Labels found: $LABELS"
            
            if echo "$LABELS" | grep -q "release:major"; then
              echo "type=major" >> "$GITHUB_OUTPUT"
            elif echo "$LABELS" | grep -q "release:minor"; then
              echo "type=minor" >> "$GITHUB_OUTPUT"
            elif echo "$LABELS" | grep -q "release:patch"; then
              echo "type=patch" >> "$GITHUB_OUTPUT"
            else
              echo "type=none" >> "$GITHUB_OUTPUT"
              echo "::notice::No release label found, will keep current version"
            fi
          else
            echo "type=none" >> "$GITHUB_OUTPUT"
            echo "::notice::No merged PR found, will keep current version"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: CALCULATE SEMANTIC VERSION
        id: semver
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION=${LATEST_TAG#v}
          
          # SSeparate major.minor.patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Increment according to the type
          VERSION_TYPE="${{ steps.get_version_type.outputs.type }}"

          if [ "$VERSION_TYPE" = "none" ]; then
            # No label, keep the current version
            NEW_VERSION="$LATEST_TAG"
            echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
            echo "version_type=no-change" >> "$GITHUB_OUTPUT"
            echo "::notice::No release label, keeping current version $NEW_VERSION"
          else
            # Increment the version
            case "$VERSION_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
            echo "version_type=$VERSION_TYPE" >> "$GITHUB_OUTPUT"
            echo "::notice::New version will be $NEW_VERSION (type: $VERSION_TYPE)"
          fi

  build_unix_package:
    name: build unix package
    needs: [calculate_version]
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: CREATE UNIX SOURCE ARCHIVE
        run: |
          mkdir -p release-package
          cp -r client server common libs scripts tests CMakeLists.txt CMakePresets.json vcpkg.json release-package/
          cd release-package
          tar -czf ../r-type-unix-${{ needs.calculate_version.outputs.version }}.tar.gz .
          cd ..

      - name: UPLOAD UNIX ARTIFACT
        uses: actions/upload-artifact@v4
        with:
          name: unix-package
          path: r-type-unix-${{ needs.calculate_version.outputs.version }}.tar.gz
          retention-days: 1

  build_windows_package:
    name: build windows package
    needs: [calculate_version]
    if: ${{ github.event_name == 'push' }}
    runs-on: windows-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: CACHE VCPKG
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~\AppData\Local\vcpkg
          key: ${{ runner.os }}-vcpkg-release-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-release-
            ${{ runner.os }}-vcpkg-

      - name: INSTALL VCPKG
        run: |
          if (-not (Test-Path "vcpkg")) {
            git clone https://github.com/Microsoft/vcpkg.git
            cd vcpkg
            .\bootstrap-vcpkg.bat
          }
          echo "VCPKG_ROOT=$PWD\vcpkg" >> $env:GITHUB_ENV

      - name: CACHE CMAKE BUILD
        uses: actions/cache@v4
        with:
          path: |
            build/windows
            ~\AppData\Local\cmake
          key: ${{ runner.os }}-cmake-release-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-cmake-release-
            ${{ runner.os }}-cmake-

      - name: BUILD PROJECT
        run: |
          .\scripts\compile_project.bat

      - name: CREATE WINDOWS BINARIES ARCHIVE
        run: |
          New-Item -ItemType Directory -Force -Path "r-type-client-windows"
          Copy-Item -Path "build\windows\bin\client\*.exe" -Destination "r-type-client-windows\" -ErrorAction SilentlyContinue
          Copy-Item -Path "build\windows\bin\client\*.dll" -Destination "r-type-client-windows\" -ErrorAction SilentlyContinue
          Compress-Archive -Path "r-type-client-windows" -DestinationPath "r-type-client-windows-${{ needs.calculate_version.outputs.version }}.zip"
          New-Item -ItemType Directory -Force -Path "r-type-server-windows"
          Copy-Item -Path "build\windows\bin\server\*.exe" -Destination "r-type-server-windows\" -ErrorAction SilentlyContinue
          Copy-Item -Path "build\windows\bin\server\*.dll" -Destination "r-type-server-windows\" -ErrorAction SilentlyContinue
          Compress-Archive -Path "r-type-server-windows" -DestinationPath "r-type-server-windows-${{ needs.calculate_version.outputs.version }}.zip"

      - name: UPLOAD WINDOWS CLIENT ARTIFACT
        uses: actions/upload-artifact@v4
        with:
          name: windows-client-package
          path: r-type-client-windows-${{ needs.calculate_version.outputs.version }}.zip
          retention-days: 1

      - name: UPLOAD WINDOWS SERVER ARTIFACT
        uses: actions/upload-artifact@v4
        with:
          name: windows-server-package
          path: r-type-server-windows-${{ needs.calculate_version.outputs.version }}.zip
          retention-days: 1

  create_release:
    name: create unified release
    needs: [calculate_version, build_unix_package, build_windows_package]
    if: ${{ github.event_name == 'push' }}
    environment: RTYPE
    runs-on: ubuntu-latest
    steps:
      - name: CHECKOUT
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: DOWNLOAD UNIX ARTIFACT
        uses: actions/download-artifact@v4
        with:
          name: unix-package
          path: ./artifacts

      - name: DOWNLOAD WINDOWS CLIENT ARTIFACT
        uses: actions/download-artifact@v4
        with:
          name: windows-client-package
          path: ./artifacts

      - name: DOWNLOAD WINDOWS SERVER ARTIFACT
        uses: actions/download-artifact@v4
        with:
          name: windows-server-package
          path: ./artifacts

      - name: CREATE UNIFIED RELEASE
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.calculate_version.outputs.version }}
          allowUpdates: true
          name: Release ${{ needs.calculate_version.outputs.version }}
          body: |
            Automated release ${{ needs.calculate_version.outputs.version }}
            
            **Version Type:** `${{ needs.calculate_version.outputs.version_type }}`

            ## ðŸ“¦ Windows Installation
            1. Download `r-type-client-windows-${{ needs.calculate_version.outputs.version }}.zip` and `r-type-server-windows-${{ needs.calculate_version.outputs.version }}.zip`
            2. Unzip the archives
            3. Run `r-type_client.exe` or `r-type_server.exe`

            ## ðŸ“¦ Unix Installation
            1. Download `r-type-unix-${{ needs.calculate_version.outputs.version }}.tar.gz`
            2. Extract: `tar -xzf r-type-unix-${{ needs.calculate_version.outputs.version }}.tar.gz`
            3. Compile: `chmod +x scripts/compile_project.sh && ./scripts/compile_project.sh`
          draft: false
          prerelease: false
          artifacts: "artifacts/*"
          artifactContentType: application/octet-stream
